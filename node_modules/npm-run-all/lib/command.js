#!/usr/bin/env node
"use strict";

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { "default": obj }; };

var _runAll = require("./index");

var _runAll2 = _interopRequireWildcard(_runAll);

if (require.main === module) {
  main(process.argv.slice(2));
}

function printHelp() {
  console.log("\nUsage: npm-run-all [OPTIONS] [...tasks]\n\n  Run specified tasks.\n\n  Options:\n    -h, --help                  Print this text.\n    -p, --parallel [...tasks]   Grouping tasks to run on parallel.\n    -s, --sequential [...tasks] Grouping tasks to run on sequential.\n    -v, --version               Print version number.\n\n  See Also:\n    https://github.com/mysticatea/npm-run-all\n");
}

function printVersion() {
  console.log("v" + require("../package.json").version);
}

function createQueue(args) {
  return args.reduce(function (queue, arg) {
    switch (arg) {
      case "-s":
      case "--sequential":
        queue.push({ parallel: false, tasks: [] });
        break;

      case "-p":
      case "--parallel":
        queue.push({ parallel: true, tasks: [] });
        break;

      default:
        if (arg[0] === "-") {
          throw new Error("Invalid Option: " + arg);
        }
        queue[queue.length - 1].tasks.push(arg);
        break;
    }
    return queue;
  }, [{ parallel: false, tasks: [] }]);
}

/*eslint no-process-exit:0*/
function main(args) {
  if (args.length === 0) {
    args.push("--help");
  }
  switch (args[0]) {
    case "-h":
    case "--help":
      printHelp();
      return;

    case "-v":
    case "--version":
      printVersion();
      return;
  }

  var queue = undefined;
  try {
    queue = createQueue(args);
  } catch (err) {
    console.error(err.message);
    process.exit(1);
  }

  (function next() {
    var group = queue.shift();
    if (group == null) {
      return;
    }
    if (group.tasks.length === 0) {
      next();
      return;
    }
    _runAll2["default"](group.tasks, {
      stdout: process.stdout,
      stderr: process.stderr,
      parallel: group.parallel
    }).then(next, function () {
      return process.exit(1);
    });
  })();
}