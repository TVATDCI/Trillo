"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = runAll;

var _spawn = require("child_process");

function toArray(x) {
  if (x == null) {
    return [];
  }
  return Array.isArray(x) ? x : [x];
}

function defineExec() {
  if (process.platform === "win32") {
    var _ret = (function () {
      var FILE = process.env.comspec || "cmd.exe";
      var OPTIONS = { windowsVerbatimArguments: true };
      return {
        v: function (command) {
          return _spawn.spawn(FILE, ["/s", "/c", "\"" + command + "\""], OPTIONS);
        }
      };
    })();

    if (typeof _ret === "object") {
      return _ret.v;
    }
  } else {
    return function (command) {
      return _spawn.spawn("/bin/sh", ["-c", command]);
    };
  }
}

var exec = defineExec();

function runTask(task, stdin, stdout, stderr) {
  return new Promise(function (resolve, reject) {
    // Execute.
    var cp = exec("npm run-script " + task);

    // Piping stdio.
    if (stdin) {
      stdin.pipe(cp.stdin);
    }
    if (stdout) {
      cp.stdout.pipe(stdout);
    }
    if (stderr) {
      cp.stderr.pipe(stderr);
    }

    // Register
    cp.on("exit", function (code) {
      if (code) {
        reject(new Error("" + task + ": None-Zero Exit(" + code + ");"));
      } else {
        resolve(null);
      }
    });
    cp.on("error", reject);
  });
}

function runAll(_tasks, _options) {
  var tasks = toArray(_tasks);
  if (tasks.length === 0) {
    return Promise.resolve(null);
  }

  var options = _options || {};
  var parallel = Boolean(options.parallel);
  var stdin = options.stdin || null;
  var stdout = options.stdout || null;
  var stderr = options.stderr || null;

  if (parallel) {
    return Promise.all(tasks.map(function (task) {
      return runTask(task, stdin, stdout, stderr);
    }));
  }
  return (function next() {
    var task = tasks.shift();
    return task && runTask(task, stdin, stdout, stderr).then(next);
  })();
}

module.exports = exports["default"];